import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import sqlite3

class CrystalDefectModel:
    def __init__(self):
        # Параметры для графена
        self.default_params = {
            'a': 2.46e-10,  # параметр решетки (м)
            'c': 3.35e-10,  # межслоевое расстояние (м)
        }
        
        # Инициализация базы данных
        self.init_database()
    
    def init_database(self):
        """Инициализация базы данных"""
        self.conn = sqlite3.connect(':memory:')
        cursor = self.conn.cursor()
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS materials (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE,
            a FLOAT,
            c FLOAT
        )
        ''')
        
        # Добавляем параметры графена
        cursor.execute('''
        INSERT OR IGNORE INTO materials (name, a, c)
        VALUES (?, ?, ?)
        ''', ('graphene', self.default_params['a'], self.default_params['c']))
        
        self.conn.commit()
    
    def get_material_params(self, material):
        """Получение параметров материала"""
        cursor = self.conn.cursor()
        cursor.execute('SELECT * FROM materials WHERE name=?', (material,))
        result = cursor.fetchone()
        
        if result is None:
            raise ValueError(f"Материал {material} не найден")
        
        return {'a': result[2], 'c': result[3]}
    
    def visualize_3d_lattice(self, material='graphene', size=5, force=0):
        """3D визуализация кристаллической решетки"""
        params = self.get_material_params(material)
        a, c = params['a'], params['c']
        
        # Создаем атомы решетки
        positions = []
        for layer in range(2):
            z = 0 if layer == 0 else c
            for i in range(size):
                for j in range(size):
                    # Атомы типа A
                    x = a * (i + 0.5 * j)
                    y = a * (j * np.sqrt(3) / 2)
                    positions.append([x, y, z])
                    
                    # Атомы типа B
                    x = a * (i + 0.5 * j + 0.5)
                    y = a * (j * np.sqrt(3)/2 + np.sqrt(3)/6)
                    positions.append([x, y, z])
        
        positions = np.array(positions)
        
        # Применяем деформацию от силы
        if force > 0:
            center = np.mean(positions, axis=0)
            for i in range(len(positions)):
                dist = np.linalg.norm(positions[i,:2] - center[:2])
                if dist < a*1.5:  # Деформируем только центральную область
                    direction = (positions[i] - center)
                    if np.linalg.norm(direction) > 0:
                        direction = direction / np.linalg.norm(direction)
                    deformation = force * 0.2 * (1 - dist/(a*1.5))
                    positions[i] += direction * deformation
        
        # Создаем фигуру
        fig = plt.figure(figsize=(10, 7))
        ax = fig.add_subplot(111, projection='3d')
        
        # Цвета атомов
        colors = np.array([[0, 0, 1]] * len(positions))  # Синий по умолчанию
        colors[::2] = [1, 0.5, 0]  # Оранжевый для атомов типа A
        
        # Отображаем атомы
        ax.scatter(positions[:,0], positions[:,1], positions[:,2], 
                  c=colors, s=50, depthshade=True)
        
        # Отображаем связи
        for i in range(0, len(positions), 2):
            for j in [i+1, i+3, i+4]:  # Связи с ближайшими атомами
                if j < len(positions):
                    x = [positions[i,0], positions[j,0]]
                    y = [positions[i,1], positions[j,1]]
                    z = [positions[i,2], positions[j,2]]
                    ax.plot(x, y, z, 'gray', linewidth=1, alpha=0.8)
        
        ax.set_title(f'3D модель {material}\nСила: {force:.2f}')
        ax.set_xlabel('X (м)')
        ax.set_ylabel('Y (м)')
        ax.set_zlabel('Z (м)')
        
        plt.tight_layout()
        plt.show()
